---
title: "Calibration of varbvs and BVSR methods"
author: "Peter Carbonetto"
date: September 5, 2017
output:
  html_document:
    theme: readable
    toc: false
    toc_float: false
    include:
      before_body: include/header.html
      after_body: include/footer.html
---

*Give introduction to analysis here.*

```{r knitr, echo=FALSE}
knitr::opts_chunk$set(
  eval      = TRUE,
  comment   = "#",
  results   = "hold",
  collapse  = TRUE,
  fig.align = "center")
```

## Set up experiment

These variables control the settings for simulating the data set and
running the algorithms: number of samples (n); number of variables, or
genetic markers (p); number of quantitative trait loci (na); variance
of the residual (se); proportion of variance in trait explained by
QTLs (r); length of Markov chain for simulating from BVSR posterior
(ns); candidate values for the prior log-odds of inclusion (logodds);
and seed for initializing the random number generator.

```{r analysis-settings}
n  <- 800
p  <- 2000
na <- 20
se <- 4
r  <- 0.5
ns <- 1e5
logodds <- seq(-3,-1,0.1)
set.seed(1)
```

Next, load a few packages, as well as some additional functions I
implemented for this analysis.

```{r load-pkgs}
library(ggplot2)
library(cowplot)
library(varbvs)
source("../code/gemma.R")
```

## Generate data set

Generate the minor allele frequencies so that they are uniform over
range $[0.05, 0.5]$. Then simulate genotypes assuming all markers
are uncorrelated (*i.e.*, unlinked), according to the minor allele
frequencies specified by vector "maf".

```{r sim-markers}
maf <- 0.05 + 0.45*runif(p)
X   <- (runif(n*p) < maf) +
       (runif(n*p) < maf)
X   <- matrix(as.double(X),n,p,byrow = TRUE)
colnames(X) <- paste0("rs",sample(1e6,p))
```

Generate additive effects for the markers so that exactly "na" of them
have a nonzero effect on the trait.

```{r sim-effects}
i       <- sample(p,na)
beta    <- rep(0,p)
beta[i] <- rnorm(na)
```

Adjust the QTL effects so that we control for the proportion of
variance explained (r). That is, we adjust beta so that $r = a/(a+1)$,
where I've defined $a = \beta^T \mathrm{cov}(X) \beta$. Here, "sb" is the
variance of the (nonzero) QTL effects.

```{r adjust-effects}
sb   <- r/(1-r)/var(c(X %*% beta))
beta <- sqrt(sb*se) * beta
```

Generate a random intercept.
 
```{r sim-intercept}
mu <- rnorm(1)
```

Generate the quantitative trait measurements.

```{r sim-trait}
y <- c(mu + X %*% beta + sqrt(se)*rnorm(n))
```

## Fit varbvs model

Fit the fully-factorized variational approximation to the posterior
distribution of the coefficients for a linear regression model of a
continuous outcome (quantitiative trait), with spike-and-slab priors on
the coefficients.

```{r fit-varbvs, results="hide", cache=TRUE}
fit.varbvs <- varbvs(X,NULL,y,"gaussian",logodds = logodds,sa = sb)
```
					 
## Fit BVSR model

Fit (nearly) the same model, but using an MCMC algorithm to simulate
the posterior distribution instead of computing approximate posterior
probabilities using a variational approximation. In the GEMMA
software, this is called the BVSR model, short for "Bayesian variable
selection in regression."

```{r fit-bvsr, results="hide", cache=TRUE}
fit.bvsr <- mcmc.bvsr(X,y)
```

## Compare varbvs and BVSR results

Compute the false positive rate (FPR) at each posterior inclusion
probability (PIP) threshold.

```{r compute-fpr}
fpr  <- data.frame(pip.cutoff = seq(0,1,0.01),varbvs = 0,bvsr = 0)
pip1 <- fit.varbvs$pip
pip2 <- fit.bvsr$pip
fpr[1,-1]   <- 1
fpr[101,-1] <- 0
for (i in 2:100) {
  d <- fpr$pip.cutoff[i]
  fpr$varbvs[i] <- sum(pip1 >= d & beta == 0) / sum(pip1 >= d)
  fpr$bvsr[i]   <- sum(pip2 >= d & beta == 0) / sum(pip2 >= d)
}
```

```{r plot-fpr-vs-threshold, fig.width=4, fig.height=3.5}
print(ggplot(fpr,aes(x = pip.cutoff)) +
      geom_line(aes(y = varbvs),color = "darkorange",size = 1) +
      geom_line(aes(y = bvsr),color = "darkblue",linetype = "dashed",
      	        size = 1) +
  labs(x = "PIP threshold",y = "FPR"))
```

## Session information

This is the version of R and the packages that were used to generate
these results.

```{r session-info}
sessionInfo()
```
