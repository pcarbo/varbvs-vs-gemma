---
title: "Calibration of varbvs and BSLMM methods"
author: "Peter Carbonetto"
date: September 5, 2017
output:
  html_document:
    theme: readable
    toc: false
    toc_float: false
    include:
      before_body: include/header.html
      after_body: include/footer.html
---

*Give introduction to analysis here.*

```{r knitr, echo=FALSE}
knitr::opts_chunk$set(
  eval      = TRUE,
  comment   = "#",
  results   = "hold",
  collapse  = TRUE,
  fig.align = "center")
```

## Setup

These variables control the settings for simulating the data set and
running the algorithms: number of samples (n); number of variables, or
genetic markers (p); number of quantitative trait loci (na); variance
of the residual (se); proportion of variance in trait explained by
QTLs (r); length of Markov chain for simulating from BSLMM posterior
(ns); candidate values for the prior log-odds of inclusion (logodds);
and seed for initializing the random number generator.

```{r analysis-settings}
n  <- 800
p  <- 2000
na <- 20
se <- 4
r  <- 0.5
ns <- 1e5
logodds <- seq(-3,-1,0.1)
set.seed(1)
```

Next, load a few packages, as well as some additional functions I
implemented for this analysis.

```{r load-pkgs}
library(ggplot2)
library(cowplot)
library(varbvs)
source("../code/gemma.R")
```

## Generate data set

Generate the minor allele frequencies so that they are uniform over
range $\[0.05, 0.5\]$. Then simulate genotypes assuming all markers
are uncorrelated (*i.e.*, unlinked), according to the minor allele
frequencies specified by vector "maf".

```{r sim-markers}
maf <- 0.05 + 0.45*runif(p)
X   <- (runif(n*p) < maf) +
       (runif(n*p) < maf)
X   <- matrix(as.double(X),n,p,byrow = TRUE)
colnames(X) <- paste0("rs",sample(1e6,p))
```

Generate additive effects for the markers so that exactly "na" of them
have a nonzero effect on the trait.

```{r sim-effects}
i       <- sample(p,na)
beta    <- rep(0,p)
beta[i] <- rnorm(na)
```

Adjust the QTL effects so that we control for the proportion of
variance explained (r). That is, we adjust beta so that $r = a/(a+1)$,
where I've defined $a = \beta^T \mathrm{cov}(X) \beta$. Here, "sb" is the
variance of the (nonzero) QTL effects.

```{r adjust-effects}
sb   <- r/(1-r)/var(c(X %*% beta))
beta <- sqrt(sb*se) * beta
```

Generate a random intercept.
 
```{r sim-intercept}
mu <- rnorm(1)
```

Generate the quantitative trait measurements.

```{r sim-trait}
y <- c(mu + X %*% beta + sqrt(se)*rnorm(n))
```

## Fit varbvs model

Fit the fully-factorized variational approximation to the posterior
distribution of the coefficients for a linear regression model of a
continuous outcome (quantitiative trait), with spike-and-slab priors on
the coefficients.

```{r fit-varbvs, results="hide", cache=TRUE}
fit.varbvs <- varbvs(X,NULL,y,"gaussian",logodds = logodds,sa = sb)
```
					 
## Fit BSLMM model

```{r fit-bslmm, results="hide", cache=TRUE}
fit.bslmm <- bslmm(X,y)
```

## Compare varbvs and BSLMM results

Compute the false positive rate (FPR) at each PIP threshold.

```{r compute-fpr}
fpr <- data.frame(pip.cutoff = seq(0,1,0.01),varbvs = 0,bslmm = 0)
for (i in 1:101) {

  # Get the PIP threshold.
  r <- fpr$pip.cutoff[i]

  # Compute the FPR for the varbvs method.
  np            <- sum(fit.varbvs$pip >= r)
  nfp           <- sum(fit.varbvs$pip >= r & beta == 0)
  fpr$varbvs[i] <- nfp / np

  # Compute the FPR for the BSLMM method.
  np           <- sum(fit.bslmm$pip >= r)
  nfp          <- sum(fit.bslmm$pip >= r & beta == 0)
  fpr$bslmm[i] <- nfp / np
}
```

```{r plot-fpr-vs-threshold}
print(ggplot(fpr,aes(x = pip.cutoff)) +
      geom_line(aes(y = varbvs),color = "darkorange") +
      geom_line(aes(y = bslmm),color = "darkblue",linetype = "dashed"))
```

## Session information

This is the version of R and the packages that were used to generate
these results.

```{r session-info}
sessionInfo()
```
